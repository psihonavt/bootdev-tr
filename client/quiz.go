package api

import (
	"context"
	"encoding/json"
	"fmt"
	"os"
	"strings"

	"github.com/anthropics/anthropic-sdk-go"
	"github.com/anthropics/anthropic-sdk-go/option"
	dao "github.com/bootdotdev/bootdev/db"
)

// GeneratedQuestion represents a question generated by Claude
type GeneratedQuestion struct {
	Question    string   `json:"question"`
	Choices     []string `json:"choices"`
	Answer      string   `json:"answer"`
	Explanation string   `json:"explanation"`
}

// GenerateQuiz generates a quiz using Claude API based on course content
func GenerateQuiz(c *Course, questionsNumber int) (*dao.Quiz, error) {
	// Concatenate all lesson content
	var contentBuilder strings.Builder
	lessons := c.GetLessons()

	for i, lesson := range lessons {
		if lesson.Content != "" {
			contentBuilder.WriteString(fmt.Sprintf("Lesson %d: %s\n", i+1, lesson.Title))
			contentBuilder.WriteString(lesson.Content)
			contentBuilder.WriteString("\n\n")
		}
	}

	courseContent := contentBuilder.String()
	if courseContent == "" {
		return nil, fmt.Errorf("no content available in course lessons")
	}

	// Generate questions using Claude API
	questions, err := generateQuestionsWithClaude(courseContent, questionsNumber)
	if err != nil {
		return nil, fmt.Errorf("failed to generate questions: %w", err)
	}

	// Convert to dao.Quiz format
	quiz := &dao.Quiz{
		CourseUUID: c.UUID,
		Questions:  make([]dao.Question, len(questions)),
	}

	for i, q := range questions {
		choicesJSON, err := json.Marshal(q.Choices)
		if err != nil {
			return nil, fmt.Errorf("failed to marshal choices: %w", err)
		}

		quiz.Questions[i] = dao.Question{
			ID:            int64(i + 1), // Temporary ID
			QuizID:        0,            // Will be set when saved to DB
			QuestionType:  "multiple_choice",
			QuestionText:  q.Question,
			Explanation:   q.Explanation,
			AnswerChoices: string(choicesJSON),
			CorrectAnswer: q.Answer,
		}
	}

	return quiz, nil
}

// generateQuestionsWithClaude calls Claude API to generate quiz questions
func generateQuestionsWithClaude(content string, numQuestions int) ([]GeneratedQuestion, error) {
	apiKey := os.Getenv("ANTHROPIC_API_KEY")
	if apiKey == "" {
		return nil, fmt.Errorf("ANTHROPIC_API_KEY environment variable not set")
	}

	client := anthropic.NewClient(option.WithAPIKey(apiKey))

	prompt := fmt.Sprintf(`Based on the following course content, generate exactly %d multiple choice questions. Each question should:

1. Test understanding of key concepts from the content
2. Have exactly 4 answer choices (A, B, C, D)  
3. Have one clearly correct answer
4. Include a brief explanation of why the answer is correct
5. DO NOT reuse or duplicate any questions that are already present in the lesson content
6. Create entirely NEW questions that test the same concepts in different ways
7. Avoid copying exact wording or examples from the lesson text

Please respond with a valid JSON array in this exact format:
[
  {
    "question": "What is...",
    "choices": ["Choice A", "Choice B", "Choice C", "Choice D"],
    "answer": "Choice A",
    "explanation": "This is correct because..."
  }
]

Course Content:
%s

IMPORTANT: Generate completely original questions that test understanding of the concepts taught, but do NOT copy or reuse any existing questions from the content above. Respond ONLY with the JSON array, no additional text.`, numQuestions, content)

	resp, err := client.Messages.New(context.Background(), anthropic.MessageNewParams{
		Model:     anthropic.ModelClaude3_5Sonnet20241022,
		MaxTokens: 8192, // Maximum tokens for Claude 3.5 Sonnet
		Messages: []anthropic.MessageParam{
			anthropic.NewUserMessage(anthropic.NewTextBlock(prompt)),
		},
	})
	if err != nil {
		return nil, fmt.Errorf("failed to call Claude API: %w", err)
	}

	if len(resp.Content) == 0 {
		return nil, fmt.Errorf("no content in Claude response")
	}

	// Extract text from the response
	var responseText string
	for _, content := range resp.Content {
		if textBlock := content.AsText(); textBlock.Text != "" {
			responseText += textBlock.Text
		}
	}

	if responseText == "" {
		return nil, fmt.Errorf("no text content in Claude response")
	}

	// Parse the generated questions
	var questions []GeneratedQuestion
	if err := json.Unmarshal([]byte(responseText), &questions); err != nil {
		return nil, fmt.Errorf("failed to parse generated questions: %w", err)
	}

	if len(questions) != numQuestions {
		return nil, fmt.Errorf("expected %d questions, got %d", numQuestions, len(questions))
	}

	return questions, nil
}
